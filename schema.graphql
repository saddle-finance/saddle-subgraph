type SystemInfo @entity {
  id: ID!

  poolRegistryContract: Bytes

  exchangeCount: BigInt!
  swapCount: BigInt!
  tokenCount: BigInt!

  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

type Swap @entity {
  " Pool address "
  id: ID!

  " Pool's human-readable name "
  name: String!

  " Reference asset type "
  assetType: AssetType

  " Identify whether pool is a metapool "
  isMeta: Boolean!

  " Registry contract address from where this pool was registered "
  registryAddress: Bytes!

  # swap address
  address: Bytes!

  # metaswap deposit address if metapool
  depositAddress: Bytes

  " Address of the token representing LP share TODO: use LPToken"
  lpToken: LpToken!

  " Number of coins in the pool "
  coinCount: BigInt!

  " List of the swappable coins within the pool "
  coins: [Coin!] @derivedFrom(field: "swap")

  " Number of underlying coins in the pool "
  underlyingCount: BigInt!

  " List of the swappable underlying coins within the pool "
  underlyingCoins: [UnderlyingCoin!] @derivedFrom(field: "swap")

  # amplification coefficient
  A: BigInt!

  swapFee: BigInt!
  " Admin fee is represented as a percentage of the total fee collected on a swap "
  adminFee: BigInt!
  virtualPrice: BigInt!

  paused: Boolean!

  addedAt: BigInt!
  addedAtBlock: BigInt!
  addedAtTransaction: Bytes!

  removedAt: BigInt
  removedAtBlock: BigInt
  removedAtTransaction: Bytes

  # owner address
  owner: Bytes!

  events: [SwapEvent!] @derivedFrom(field: "swap")

  exchanges: [Exchange!] @derivedFrom(field: "swap")

  exchangeCount: BigInt!

  # cumulative hourly trade volume
  hourlyVolumes: [HourlyVolume!] @derivedFrom(field: "swap")

  # cumulative daily trade volume
  dailyVolumes: [DailyVolume!] @derivedFrom(field: "swap")

  # cumulative weekly trade volume
  weeklyVolumes: [WeeklyVolume!] @derivedFrom(field: "swap")
}

type LpToken @entity {
  id: ID!
  address: Bytes!
  decimals: BigInt!
  name: String
  symbol: String
  swap: Swap
}

interface TradeVolume @entity {
  swap: Swap!
  timestamp: BigInt!
  volume: BigDecimal!
}

type DailyVolume implements TradeVolume @entity {
  id: ID!
  swap: Swap!
  timestamp: BigInt!
  volume: BigDecimal!
}

type HourlyVolume implements TradeVolume @entity {
  id: ID!
  swap: Swap!
  timestamp: BigInt!
  volume: BigDecimal!
}

type WeeklyVolume implements TradeVolume @entity {
  id: ID!
  swap: Swap!
  timestamp: BigInt!
  volume: BigDecimal!
}

interface SwapEvent @entity {
  swap: Swap!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type NewAdminFeeEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  newFee: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type OwnershipTransferredEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  previousOwner: Bytes!
  newOwner: Bytes!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type PausedEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type UnpausedEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type NewSwapFeeEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  newFee: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type NewWithdrawFeeEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  newFee: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type RampAEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  oldA: BigInt!
  newA: BigInt!
  initialTime: BigInt!
  futureTime: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type StopRampAEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  currentA: BigInt!
  time: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type AddLiquidityEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  provider: Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]!
  invariant: BigInt
  lpTokenSupply: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type RemoveLiquidityEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  provider: Bytes!
  tokenAmounts: [BigInt!]!
  fees: [BigInt!]
  invariant: BigInt
  lpTokenSupply: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type FlashLoanEvent implements SwapEvent @entity {
  id: ID!
  swap: Swap!
  receiver: Bytes!
  tokenIndex: Int!
  amount: BigInt!
  amountFee: BigInt!
  protocolFee: BigInt!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

interface Exchange {
  swap: Swap!

  buyer: Bytes!
  tokenSold: Token!
  tokenBought: Token!
  amountSold: BigDecimal!
  amountBought: BigDecimal!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type TokenExchange implements Exchange @entity {
  id: ID!
  swap: Swap!
  buyer: Bytes!
  tokenSold: Token!
  tokenBought: Token!
  amountSold: BigDecimal!
  amountBought: BigDecimal!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

type TokenExchangeUnderlying implements Exchange @entity {
  id: ID!
  swap: Swap!
  buyer: Bytes!
  tokenSold: Token!
  tokenBought: Token!
  amountSold: BigDecimal!
  amountBought: BigDecimal!

  block: BigInt!
  timestamp: BigInt!
  transaction: Bytes!
}

" Representation of canonical ERC20s "
type Token @entity {
  id: ID!
  address: Bytes!
  decimals: BigInt!
  name: String
  symbol: String

  swaps: [Swap!]

  coins: [Coin!] @derivedFrom(field: "token")

  underlyingCoins: [UnderlyingCoin!] @derivedFrom(field: "token")
}

" Basically a Pool-Token join table "
type Coin @entity {
  " Equals to: <pool_id>-<coin_index>"
  id: ID!

  " Coin index "
  index: Int!

  swap: Swap!

  token: Token!

  balance: BigDecimal!

  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

" Basically a Pool-Token join table "
type UnderlyingCoin @entity {
  " Equals to: <pool_id>-<coin_index>"
  id: ID!

  " Coin index "
  index: Int!

  swap: Swap!

  token: Token!

  balance: BigDecimal!

  updated: BigInt!
  updatedAtBlock: BigInt!
  updatedAtTransaction: Bytes!
}

enum AssetType {
  BTC
  ETH
  USD
  OTHER
}
